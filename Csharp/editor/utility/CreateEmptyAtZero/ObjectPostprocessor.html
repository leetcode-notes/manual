

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>utility ObjectPostprocessor &mdash; All-Tool-Manual 0.00 ドキュメント</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/showreel.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="../../../../genindex.html"/>
        <link rel="search" title="検索" href="../../../../search.html"/>
    <link rel="top" title="All-Tool-Manual 0.00 ドキュメント" href="../../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> All-Tool-Manual
          

          
          </a>

          
            
            
              <div class="version">
                0.00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../CPlus/CPlus.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../csharp.html">C#</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Render/Rendaring.html">Rendaring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ZScript/Zscript.html">ZScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../algorithm/algorytm.html">algorytm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bat/cmd.html">cmd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../game/game.html">game memo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../git/git.html">git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../houdini/houdini.html">Houdini</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../javascript/javascript.html">javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../linux/linux.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../maya/maya.html">maya Tool manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindmap/mindmap.html">manual mindmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../shader/shader.html">shader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../shotgun/shotgun.html">Shotgun manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/com.html">tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../web/web.html">web application framework etc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">All-Tool-Manual</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
    <li>utility ObjectPostprocessor</li>
    <li class="wy-breadcrumbs-aside">
      
          <a href="https://github.com/Csharp/editor/utility/CreateEmptyAtZero/ObjectPostprocessor.rst" class="fa fa-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="utility-objectpostprocessor">
<h1>utility ObjectPostprocessor<a class="headerlink" href="#utility-objectpostprocessor" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Copyright (c) 2017 Nora
// Released under the MIT license
// http://opensource.org/licenses/mit-license.php

//#define OBJECTPOSTPROCESSOR_DEBUGLOG

using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;
using UnityEditor.SceneManagement;

namespace EditorExtensions
{

[InitializeOnLoad]
public class ObjectPostprocessor : AssetPostprocessor
{
    public delegate void AssetAddedHandler( string assetPath );
	public static event AssetAddedHandler assetAdded;

    public delegate void AssetMovedHandler( string assetPathFrom, string assetPathTo );
	public static event AssetMovedHandler assetMoved;

    public delegate void AssetDeletedHandler( string assetPath );
	public static event AssetDeletedHandler assetDeleted;

    public delegate void AssetDuplicatedHandler( string assetPathFrom, string assetPathTo );
	public static event AssetDuplicatedHandler assetDuplicated;

    public delegate void PrefabConnectedHandler( GameObject gameObjectFrom, string assetPathTo );
	public static event PrefabConnectedHandler prefabConnected;

    public delegate void GameObjectAddedHandler( GameObject gameObject );
	public static event GameObjectAddedHandler gameObjectAdded;

    public delegate void GameObjectDeletedHandler( Scene scene );
	public static event GameObjectDeletedHandler gameObjectDeleted;

    public delegate void GameObjectSceneMovedHandler( Scene sceneFrom, GameObject gameObject );
	public static event GameObjectSceneMovedHandler gameObjectSceneMoved;

    public delegate void GameObjectDuplicatedHandler( GameObject gameObjectFrom, GameObject gameObjectTo );
	public static event GameObjectDuplicatedHandler gameObjectDuplicated;

    public delegate void PrefabInstantiatedHandler( string assetPathFrom, GameObject gameObjectTo );
	public static event PrefabInstantiatedHandler prefabInstantiated;

	//--------------------------------------------------------------------------------------------------------

	static void _AssetAdded( string assetPath )
	{
		DebugLog( &quot;AssetAdded: &quot; + assetPath );
		if( assetAdded != null ) {
			assetAdded( assetPath );
		}
	}

	static void _AssetMoved( string assetPathFrom, string assetPathTo )
	{
		DebugLog( &quot;AssetMoved: from: &quot; + assetPathFrom + &quot; to: &quot; + assetPathTo );
		if( assetMoved != null ) {
			assetMoved( assetPathFrom, assetPathTo );
		}
	}

	static void _AssetDeleted( string assetPath )
	{
		DebugLog( &quot;AssetDeleted: &quot; + assetPath );
		if( assetDeleted != null ) {
			assetDeleted( assetPath );
		}
	}

	static void _AssetDuplicated( string assetPathFrom, string assetPathTo )
	{
		DebugLog( &quot;AssetDuplicated: from: &quot; + assetPathFrom + &quot; to: &quot; + assetPathTo );
		if( assetDuplicated != null ) {
			assetDuplicated( assetPathFrom, assetPathTo );
		}
	}

	static void _PrefabConnected( GameObject gameObjectFrom, string assetPathTo )
	{
		DebugLog( &quot;PrefabConnected: gameObjectFrom: &quot; + gameObjectFrom.name + &quot; assetPathTo: &quot; + assetPathTo );
		if( prefabConnected != null ) {
			prefabConnected( gameObjectFrom, assetPathTo );
		}
	}

	static void _GameObjectAdded( GameObject gameObject )
	{
		DebugLog( &quot;GameObjectAdded: gameObject: &quot; + gameObject.name );
		if( gameObjectAdded != null ) {
			gameObjectAdded( gameObject );
		}
	}

	static void _GameObjectDeleted( Scene scene )
	{
		DebugLog( &quot;GameObjectDeleted: scene: &quot; + scene.name );
		if( gameObjectDeleted != null ) {
			gameObjectDeleted( scene );
		}
	}

	static void _GameObjectSceneMoved( Scene sceneFrom, GameObject gameObject )
	{
		DebugLog( &quot;GameObjectSceneMoved: sceneFrom: &quot; + sceneFrom.name + &quot; gameObject: &quot; + gameObject.name );
		if( gameObjectSceneMoved != null ) {
			gameObjectSceneMoved( sceneFrom, gameObject );
		}
	}

	static void _GameObjectDuplicated( GameObject gameObjectFrom, GameObject gameObjectTo )
	{
		DebugLog( &quot;GameObjectDuplicated: gameObjectFrom: &quot; + gameObjectFrom.name + &quot; gameObjectTo: &quot; + gameObjectTo.name );
		if( gameObjectDuplicated != null ) {
			gameObjectDuplicated( gameObjectFrom, gameObjectTo );
		}
	}

	static void _PrefabInstantiated( string assetPathFrom, GameObject gameObjectTo )
	{
		DebugLog( &quot;PrefabInstantiated: assetPathFrom: &quot; + assetPathFrom + &quot; gameObjectTo: &quot; + gameObjectTo.name );
		if( prefabInstantiated != null ) {
			prefabInstantiated( assetPathFrom, gameObjectTo );
		}
	}

	//--------------------------------------------------------------------------------------------------------

	[System.Diagnostics.Conditional(&quot;OBJECTPOSTPROCESSOR_DEBUGLOG&quot;)]
	static void DebugLog( string text )
	{
		Debug.Log( text );
	}

	//--------------------------------------------------------------------------------------------------------

	static bool _isPlaying;

	static HashSet&lt;string&gt; _assetPaths;
	static HashSet&lt;string&gt; _inSelection_importedAssetPaths = new HashSet&lt;string&gt;();
	static string[] _selectionPaths;

	static _GameObjectsInScenes _gameObjectsInScenes;

	static GameObject _prev_selectionGameObject;
	static GameObject _selectionGameObject;
	static GameObject[] _prev_selectionGameObjects;
	static GameObject[] _selectionGameObjects;
	static _GameObjectHierarchy _prev_selectionGameObjectHierarchy;
	static _GameObjectHierarchy _selectionGameObjectHierarchy;
	static _GameObjectSiblings[] _prev_selectionGameObjectSiblings;
	static _GameObjectSiblings[] _selectionGameObjectSiblings;

	//--------------------------------------------------------------------------------------------------------

	static ObjectPostprocessor()
	{
		_assetPaths = _GetAssetPaths();

		_SetIsPlaying( EditorApplication.isPlayingOrWillChangePlaymode || EditorApplication.isPlaying );

		EditorApplication.playModeStateChanged += _ =&gt; PlaymodeStateChanged();
		Selection.selectionChanged += SelectionChanged;
	}

	static HashSet&lt;string&gt; _GetAssetPaths()
	{
		var assetPaths = new HashSet&lt;string&gt;();
		var allAssetPaths = AssetDatabase.GetAllAssetPaths();
		if( allAssetPaths != null ) {
			foreach( var assetPath in allAssetPaths )  {
				if( _IsTargetAssetPath( assetPath ) ) {
					assetPaths.Add( assetPath );
				}
			}
		}

		return assetPaths;
	}

	static void _SetIsPlaying( bool isPlaying )
	{
		_isPlaying = isPlaying;
		if( _isPlaying ) {
			_gameObjectsInScenes = null;

			_UpdateSelection();
			_UpdatePrevSelection();

			EditorApplication.hierarchyWindowChanged -= HierarchyWindowChanged;
		} else {
			_gameObjectsInScenes = new _GameObjectsInScenes();

			_UpdateSelection();
			_UpdatePrevSelection();

			EditorApplication.hierarchyWindowChanged += HierarchyWindowChanged;
		}
	}

	static void PlaymodeStateChanged()
	{
		bool isPlaying = (EditorApplication.isPlayingOrWillChangePlaymode || EditorApplication.isPlaying);
		if( _isPlaying != isPlaying ) {
			_SetIsPlaying( isPlaying );
		}
	}

	#if false
	static GameObject CreateGameObjectInScene( UnityEngine.SceneManagement.Scene scene, string name, HideFlags hideFlags )
	{
		var gameObject = UnityEditor.EditorUtility.CreateGameObjectWithHideFlags( name, hideFlags );
		UnityEditor.SceneManagement.EditorSceneManager.MoveGameObjectToScene( gameObject, scene );
		return gameObject;
	}
	#endif

	static void OnPostprocessAllAssets( string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths )
    {
		if( deletedAssets != null ) {
			for( int i = 0; i &lt; deletedAssets.Length; ++i ) {
				if( _IsTargetAssetPath( deletedAssets[i] ) ) {
					_assetPaths.Remove( deletedAssets[i] );
					_inSelection_importedAssetPaths.Remove( deletedAssets[i] );
					_StringsSetNull( _selectionPaths, deletedAssets[i] );

					_AssetDeleted( deletedAssets[i] );
				}
			}
		}

		if( movedAssets != null ) {
			for( int i = 0; i &lt; movedAssets.Length; ++i ) {
				if( _IsTargetAssetPath( movedAssets[i] ) ) {
					if( _assetPaths.Remove( movedFromAssetPaths[i] ) ) {
						_assetPaths.Add( movedAssets[i] );
					}
					if( _inSelection_importedAssetPaths.Remove( movedFromAssetPaths[i] ) ) {
						_inSelection_importedAssetPaths.Add( movedAssets[i] );
					}
					_StringsExchange( _selectionPaths, movedFromAssetPaths[i], movedAssets[i] );

					_AssetMoved( movedFromAssetPaths[i], movedAssets[i] );
				}
			}
		}

		if( importedAssets != null ) {
			if( _IsNewAssetContains( importedAssets ) ) {
				string[] duplicatedAssetPaths = _GetDuplicatedAssetPaths( importedAssets );

				for( int i = 0; i &lt; importedAssets.Length; ++i ) {
					if( _IsTargetAssetPath( importedAssets[i] ) &amp;&amp; !_assetPaths.Contains( importedAssets[i] ) ) {
						_assetPaths.Add( importedAssets[i] );
						_inSelection_importedAssetPaths.Add( importedAssets[i] ); // Check for PrefabConnected
						if( duplicatedAssetPaths != null &amp;&amp; duplicatedAssetPaths[i] != null ) {
							_AssetDuplicated( duplicatedAssetPaths[i], importedAssets[i] );
						} else {
							_AssetAdded( importedAssets[i] );
						}
					}
				}
			}
		}
    }

	static void _StringsSetNull( string[] strings, string str )
	{
		if( strings != null ) {
			for( int i = 0; i &lt; strings.Length; ++i ) {
				if( strings[i] == str ) {
					strings[i] = null;
				}
			}
		}
	}

	static void _StringsExchange( string[] strings, string strFrom, string strTo )
	{
		if( strings != null ) {
			for( int i = 0; i &lt; strings.Length; ++i ) {
				if( strings[i] == strFrom ) {
					strings[i] = strTo;
				}
			}
		}
	}

	static bool _IsTargetAssetPath( string assetPath )
	{
		return assetPath != null &amp;&amp; assetPath.StartsWith(&quot;Assets/&quot;) &amp;&amp; !assetPath.StartsWith(&quot;Assets/__DELETED_GUID_Trash/&quot;);
	}

	static bool _IsNewAssetContains( string[] importedAssets )
	{
		if( importedAssets != null ) {
			for( int i = 0; i &lt; importedAssets.Length; ++i ) {
				if( _IsTargetAssetPath( importedAssets[i] ) &amp;&amp; !_assetPaths.Contains( importedAssets[i] ) ) {
					return true;
				}
			}
		}

		return false;
	}

	static void HierarchyWindowChanged()
	{
		_CheckSceneChanged();
		_CheckSelectionObjects_GameObjectMoved();
	}

	static void _CheckSceneChanged()
	{
		if( _gameObjectsInScenes.CheckSceneChanged() ) {
			_prev_selectionGameObjectHierarchy.CheckSceneChanged();
			_selectionGameObjectHierarchy.CheckSceneChanged();
			_CheckSceneChanged( ref _prev_selectionGameObject, _prev_selectionGameObjects, _prev_selectionGameObjectSiblings );
			_CheckSceneChanged( ref _selectionGameObject, _selectionGameObjects, _selectionGameObjectSiblings );
		}
	}

	static void _CheckSceneChanged( ref GameObject gameObject, GameObject[] gameObjects, _GameObjectSiblings[] siblings )
	{
		if( gameObjects != null &amp;&amp; siblings != null ) {
			for( int i = 0; i &lt; siblings.Length; ++i ) {
				if( siblings[i] != null &amp;&amp; !siblings[i].scene.isLoaded ) {
					if( gameObject == gameObjects[i] ) {
						gameObject = null;
					}
					gameObjects[i] = null;
					siblings[i] = null;
				}
			}
		}
	}

	static void _CheckSelectionObjects_GameObjectMoved()
	{
		if( _selectionGameObjectHierarchy == null ||
			_selectionGameObjectSiblings == null ||
			_selectionGameObjects == null ) {
			return;
		}

		for( int i = 0; i &lt; _selectionGameObjects.Length; ++i ) {
			var siblings = _selectionGameObjectSiblings[i];
			var gameObject = _selectionGameObjects[i];
			if( siblings != null &amp;&amp; gameObject != null ) {
				if( siblings.scene != gameObject.scene ) {
					_selectionGameObjectSiblings[i] = _selectionGameObjectHierarchy.Move( siblings, gameObject );
					_gameObjectsInScenes.Remove( gameObject );
					_gameObjectsInScenes.Add( gameObject );
					_GameObjectSceneMoved( siblings.scene, gameObject );
				}
			}
		}
	}

	static void _UpdatePrevSelection()
	{
		_prev_selectionGameObject = _selectionGameObject;
		_prev_selectionGameObjects = _selectionGameObjects;
		_prev_selectionGameObjectSiblings = _selectionGameObjectSiblings;
		_prev_selectionGameObjectHierarchy = _selectionGameObjectHierarchy;
	}

	static void _UpdateSelection()
	{
		var selectionObjects = Selection.objects;
		_selectionPaths = _CollectSelectionPaths( selectionObjects );

		_selectionGameObject = null;
		_selectionGameObjects = null;
		_selectionGameObjectHierarchy = null;
		_selectionGameObjectSiblings = null;

		if( _isPlaying ) {
			return;
		}

		if( selectionObjects != null &amp;&amp; selectionObjects.Length &gt; 0 ) {
			if( _selectionPaths == null || !_StringsIsFully( _selectionPaths ) ) {
				var selectionObject = Selection.activeObject;
				_selectionGameObjects = new GameObject[selectionObjects.Length];
				for( int i = 0; i &lt; selectionObjects.Length; ++i ) {
					if( selectionObjects[i] != null ) {
						if( _selectionPaths == null || string.IsNullOrEmpty( _selectionPaths[i] ) ) {
							_selectionGameObjects[i] = selectionObjects[i] as GameObject;
							if( selectionObjects[i] == selectionObject ) {
								_selectionGameObject = _selectionGameObjects[i];
							}
						}
					}
				}
			}
		}

		if( _selectionGameObjects != null &amp;&amp; _selectionGameObjects.Length &gt; 0 ) {
			_selectionGameObjectHierarchy = new _GameObjectHierarchy( _selectionGameObjects );
			_selectionGameObjectSiblings = new _GameObjectSiblings[_selectionGameObjects.Length];
			for( int i = 0; i &lt; _selectionGameObjects.Length; ++i ) {
				_selectionGameObjectSiblings[i] = _selectionGameObjectHierarchy.GetSiblings( _selectionGameObjects[i] );
			}
		} else {
			_selectionGameObjectHierarchy = new _GameObjectHierarchy( null ); // Note: Collection Root only.(for &quot;GameObject/Creat Empty&quot;)
		}
	}

	static void SelectionChanged()
	{
		_UpdatePrevSelection();
		_UpdateSelection();

		_CheckSelectionObjects();
	}

	static string[] _CollectSelectionPaths( UnityEngine.Object[] selectionObjects )
	{
		if( selectionObjects != null ) {
			string[] selectionPaths = null;
			for( int i = 0; i &lt; selectionObjects.Length; ++i ) {
				var assetPath = AssetDatabase.GetAssetPath( selectionObjects[i] );
				if( !string.IsNullOrEmpty( assetPath ) ) {
					if( selectionPaths == null ) {
						selectionPaths = new string[selectionObjects.Length];
					}
					selectionPaths[i] = assetPath;
				}
			}

			return selectionPaths;
		}

		return null;
	}

	/*
		Note: Increment Patterns for Asset Names.

		AssetName
		AssetName 1
		...

		AssetName 0
		AssetName 1
		...

		AssetName -1
		AssetName -2
		...
	*/

	struct _AssetPathTemp
	{
		public string assetPath;
		public string assetPathBase; // Without number and extention.
		public string extension;

		public ulong assetNum;

		public _AssetPathTemp( string assetPath )
		{
			this.assetPath = assetPath;
			this.assetPathBase = assetPath;
			this.extension = null;
			this.assetNum = 0;

			if( assetPath == null ) {
				return;
			}

			int length = assetPath.Length;
			if( length == 0 ) {
				return;
			}

			int extensionPos;
			int i = _SkipExtention( assetPath, out extensionPos );
			if( extensionPos &gt;= 0 ) {
				this.extension = assetPath.Substring( extensionPos );
			}

			ulong num = 0;
			int numPos = -1;
			unchecked {
				for( ulong scl = 1; i &gt;= 0; --i, scl *= 10 ) {
					char c = assetPath[i];
					ulong t = (ulong)(c - &#39;0&#39;);
					if( t &lt;= 9 ) {
						numPos = i;
						num += t * scl;
					} else {
						break;
					}
				}
			}

			this.assetNum = num;

			if( numPos &gt;= 0 ) {
				this.assetPathBase = this.assetPath.Substring( 0, numPos );
			} else if( extensionPos &gt;= 0 ) {
				this.assetPathBase = this.assetPath.Substring( 0, extensionPos ) + &quot; &quot;;
			}
		}

		public void Increment()
		{
			++this.assetNum;

			if( this.assetPathBase != null ) {
				this.assetPath = this.assetPathBase + this.assetNum.ToString();
				if( this.extension != null ) {
					this.assetPath += this.extension;
				}
			}
		}

		static int _SkipExtention( string objectName, out int extensionPos )
		{
			extensionPos = -1;

			if( objectName == null ) {
				return 0;
			}

			int length = objectName.Length;
			if( length &gt; 0 ) {
				for( int i = length - 1; i &gt;= 0; --i ) {
					char c = objectName[i];
					if( c == &#39;.&#39; ) {
						if( i &gt; 0 ) {
							extensionPos = i; // Has extention.
							return i - 1;
						} else {
							return length - 1; // No extention.
						}
					} else if( c == &#39;/&#39; || c == &#39;\\&#39; ) {
						return length - 1; // No extention.
					}
				}

				return length - 1;
			}

			return 0;
		}
	}

	// Note: Must be updated when naming rules are changed.
	static string[] _GetDuplicatedAssetPaths( string[] importedAssets )
	{
		if( _assetPaths == null || _selectionPaths == null || importedAssets == null ) {
			return null;
		}

		string[] sourceAssetPaths = null;
		HashSet&lt;string&gt; reservedAssetPaths = null;

		for( int i = 0; i &lt; _selectionPaths.Length; ++i ) {
			string assetPath = _selectionPaths[i];
			if( string.IsNullOrEmpty( assetPath ) ) {
				continue;
			}

			_AssetPathTemp destAssetPathTemp = new _AssetPathTemp( assetPath );

			for(;;) {
				destAssetPathTemp.Increment();
				if( _assetPaths.Contains( destAssetPathTemp.assetPath ) ) {
					continue;
				}
				if( reservedAssetPaths != null &amp;&amp; reservedAssetPaths.Contains( destAssetPathTemp.assetPath ) ) {
					continue;
				}

				break;
			}

			int index = _StringsIndexOf( importedAssets, destAssetPathTemp.assetPath );
			if( index &gt;= 0 ) {
				if( sourceAssetPaths == null ) {
					sourceAssetPaths = new string[importedAssets.Length];
					reservedAssetPaths = new HashSet&lt;string&gt;( _assetPaths );
				}
				sourceAssetPaths[index] = assetPath;
				reservedAssetPaths.Add( destAssetPathTemp.assetPath );
			}
		}

		return sourceAssetPaths;
	}

	static bool _StringsIsFully( string[] strings )
	{
		if( strings != null ) {
			foreach( var str in strings ) {
				if( string.IsNullOrEmpty( str ) ) {
					return false;
				}
			}

			return true;
		} else {
			return false;
		}
	}

	static bool _StringsIsEmpty( string[] strings )
	{
		if( strings != null ) {
			foreach( var str in strings ) {
				if( !string.IsNullOrEmpty( str ) ) {
					return false;
				}
			}

			return true;
		} else {
			return true;
		}
	}

	static int _StringsIndexOf( string[] strings, string str )
	{
		if( strings != null &amp;&amp; str != null ) {
			for( int i = 0; i &lt; strings.Length; ++i ) {
				if( strings[i] != null &amp;&amp; strings[i] == str ) {
					return i;
				}
			}
		}

		return -1;
	}

	/*
		Note: Increment Patterns for GameObject Names.

		GameObject
		GameObject (1)
		...

		GameObject (0)
		GameObject (1)
		...

		GameObject (-1)
		GameObject (-1) (1)
		GameObject (-1) (2)
		...

		GameObject -(0)
		GameObject - (1)
		GameObject - (2)
		...

		GameObject -(1)
		GameObject - (1)
		GameObject - (2)
		...

		GameObject -(2)
		GameObject - (2)
		GameObject - (3)
		...

		(0)
		 (1)
		...

		(1)
		 (1)
		...
	*/

	static bool _CheckNewInstanceAvailable()
	{
		if( _prev_selectionGameObjectHierarchy == null ||
			_selectionGameObjects == null ||
			_selectionGameObjects.Length == 0 ) {
			return false;
		}

		bool isNewInstanceAvailable = false;
		for( int i = 0; i &lt; _selectionGameObjects.Length; ++i ) {
			GameObject destGameObject = _selectionGameObjects[i];
			if( destGameObject == null ) {
				continue; // Asset.
			}

			if( _gameObjectsInScenes.Contains( destGameObject ) ) {
				continue; // Not new instance.
			}

			isNewInstanceAvailable = true;

			var destSiblings = _prev_selectionGameObjectHierarchy.GetSiblings( destGameObject );
			if( destSiblings != null &amp;&amp; !destSiblings.Contains( destGameObject ) ) {
				destSiblings.markNewInstanceAvailable = true; // Note: Edit _prev_selectionGameObjectHierarchy directlly.
			}
		}

		return isNewInstanceAvailable;
	}

	// Note: Must be updated when naming rules are changed.
	static GameObject[] _GetDuplicatedGameObjects()
	{
		if( _prev_selectionGameObjectHierarchy == null ||
			_prev_selectionGameObjects == null ||
			_prev_selectionGameObjects.Length == 0 ||
			_selectionGameObjects == null ||
			_selectionGameObjects.Length == 0 ) {
			return null;
		}

		Scene activeScene = new Scene();
		if( _prev_selectionGameObject != null ) {
			activeScene = _prev_selectionGameObject.scene;
		}

		GameObject[] duplicatedGameObjects = null;

		for( int i = 0; i &lt; _prev_selectionGameObjects.Length; ++i ) {
			var sourceGameObject = _prev_selectionGameObjects[i];
			if( sourceGameObject == null ) {
				continue; // Skip asset.
			}

			var index = _GetDuplicatedGameObjectIndex( sourceGameObject, activeScene );
			if( index &gt;= 0 ) {
				if( duplicatedGameObjects == null ) {
					duplicatedGameObjects = new GameObject[_selectionGameObjects.Length];
				}
				duplicatedGameObjects[index] = sourceGameObject;
			}
		}

		return duplicatedGameObjects;
	}

	static int _GetDuplicatedGameObjectIndex( GameObject sourceGameObject, Scene activeScene )
	{
		var sourceSiblings = _prev_selectionGameObjectHierarchy.GetSiblings( sourceGameObject );
		if( sourceSiblings == null || !sourceSiblings.markNewInstanceAvailable ) {
			return -1;
		}

		string gameObjectNewName = sourceGameObject.name;
		if( sourceGameObject.scene == activeScene ) { // Note: This rule is for active scene only. (Might be bug.)
			// Generate duplicated name.
			var gameObjectNameTemp = new _GameObjectNameTemp( sourceGameObject.name );
			for(;;) {
				gameObjectNameTemp.Increment();
				if( !sourceSiblings.Contains( gameObjectNameTemp.gameObjectName ) ) {
					gameObjectNewName = gameObjectNameTemp.gameObjectName;
					break;
				}
			}
		}

		for( int i = 0; i &lt; _selectionGameObjects.Length; ++i ) {
			GameObject destGameObject = _selectionGameObjects[i];
			if( destGameObject == null ) {
				continue; // Asset or same instance.
			}
			if( _gameObjectsInScenes.Contains( destGameObject ) ) {
				continue; // Not new instance.
			}

			var destSiblings = _prev_selectionGameObjectHierarchy.GetSiblings( destGameObject );
			if( destSiblings == null ) {
				continue; // No siblings. (New selected.)
			}

			if( destSiblings.Contains( destGameObject ) ) {
				continue; // Failsafe.
			}

			if( destSiblings != sourceSiblings ) {
				continue; // Different hierarchy.
			}

			if( destGameObject.name == gameObjectNewName ) {
				sourceSiblings.Add( destGameObject ); // Note: Edit _prev_selectionGameObjectHierarchy directlly.
				return i;
			}
		}

		return -1;
	}

	struct _GameObjectNameTemp
	{
		public string gameObjectName;
		public string gameObjectNameBase; // Without number and extention.

		public ulong gameObjectNum;

		public _GameObjectNameTemp( string gameObjectName )
		{
			this.gameObjectName = gameObjectName;
			this.gameObjectNameBase = gameObjectName;
			this.gameObjectNum = 0;

			if( gameObjectName == null ) {
				return;
			}

			this.gameObjectNameBase = gameObjectName + &quot; &quot;;

			int length = gameObjectName.Length;
			if( length &lt; 3 ) {
				return;
			}
			if( gameObjectName[length - 1] != &#39;)&#39; ) {
				return;
			}

			int i = length - 2;
			ulong num = 0;
			int numPos = -1;
			bool bracketFound = false;
			unchecked {
				for( ulong scl = 1; i &gt;= 0; --i, scl *= 10 ) {
					char c = gameObjectName[i];
					ulong t = (ulong)(c - &#39;0&#39;);
					if( t &lt;= 9 ) {
						numPos = i;
						num += t * scl;
					} else {
						if( c != &#39;(&#39; ) {
							return;
						}

						bracketFound = true;
						break;
					}
				}
			}

			if( !bracketFound || numPos &lt;= 0 ) {
				return;
			}

			this.gameObjectNum = num;
			this.gameObjectNameBase = this.gameObjectName.Substring( 0, numPos - 1 );
			if( string.IsNullOrEmpty( this.gameObjectNameBase ) ) {
				this.gameObjectNameBase = &quot; &quot;;
			}
		}

		public void Increment()
		{
			++this.gameObjectNum;

			if( this.gameObjectNameBase != null ) {
				this.gameObjectName = this.gameObjectNameBase + &#39;(&#39; + this.gameObjectNum.ToString() + &#39;)&#39;;
			}
		}
	}

	static void _CheckSelectionObjects()
	{
		var dragAndDropObjects = DragAndDrop.objectReferences;
		foreach( var importedAssetPath in _inSelection_importedAssetPaths ) {
			_CheckSelectionObjects_PrefabConnected( dragAndDropObjects, importedAssetPath );
		}
		_inSelection_importedAssetPaths.Clear();

		if( !_isPlaying &amp;&amp; _gameObjectsInScenes != null ) {
			_gameObjectsInScenes.CheckDeleted();

			if( _CheckNewInstanceAvailable() ) {
				var duplicatedGameObjects = _GetDuplicatedGameObjects();
				if( _selectionGameObjects != null ) {
					for( int i = 0; i &lt; _selectionGameObjects.Length; ++i ) {
						if( _selectionGameObjects[i] != null ) {
							if( !_gameObjectsInScenes.Contains( _selectionGameObjects[i] ) ) {
								_gameObjectsInScenes.Add( _selectionGameObjects[i] );
								_CheckSelectionObjects_GameObject( dragAndDropObjects, _selectionGameObjects[i],
									(duplicatedGameObjects != null) ? duplicatedGameObjects[i] : null );
							}
						}
					}
				}
			}
		}
	}

	static bool _CheckSelectionObjects_PrefabConnected( UnityEngine.Object[] dragAndDropObjects, string assetPath )
	{
		if( dragAndDropObjects != null ) {
			foreach( var obj in dragAndDropObjects ) {
				var gameObject = obj as GameObject;
				if( gameObject != null ) {
					var prefabParent = PrefabUtility.GetPrefabParent( gameObject );
					if( prefabParent != null &amp;&amp; AssetDatabase.GetAssetPath( prefabParent ) == assetPath ) {
						_PrefabConnected( gameObject, assetPath );
						return true;
					}
				}
			}
		}

		return false;
	}

	static void _CheckSelectionObjects_GameObject( UnityEngine.Object[] dragAndDropObjects, GameObject gameObject, GameObject duplicatedGameObject )
	{
		if( _CheckSelectionObjects_PrefabInstantiated( dragAndDropObjects, gameObject ) ) {
			return;
		}

		if( duplicatedGameObject != null ) {
			_GameObjectDuplicated( duplicatedGameObject, gameObject );
			return;
		}

		// Finally, this gameObject will be added
		_GameObjectAdded( gameObject );
	}

	static bool _CheckSelectionObjects_PrefabInstantiated( UnityEngine.Object[] dragAndDropObjects, GameObject gameObject )
	{
		if( dragAndDropObjects != null ) {
			var prefabParent = PrefabUtility.GetPrefabParent( gameObject );
			if( prefabParent != null &amp;&amp; _Contains( dragAndDropObjects, prefabParent ) ) {
				_PrefabInstantiated( AssetDatabase.GetAssetPath( prefabParent ), gameObject );
				return true;
			}
		}

		return false;
	}

	static bool _Contains&lt; Type &gt;( Type[] values, Type value )
		where Type : class
	{
		if( values != null ) {
			foreach( var v in values ) {
				if( v == value ) {
					return true;
				}
			}
		}

		return false;
	}

	//--------------------------------------------------------------------------------------------------------------------

	class _GameObjectsInScenes
	{
		static Dictionary&lt;Scene, HashSet&lt;GameObject&gt;&gt; _gameObjectsInScenes;

		public _GameObjectsInScenes()
		{
			_gameObjectsInScenes = _GetGameObjectsInScenes();
		}

		Dictionary&lt;Scene, HashSet&lt;GameObject&gt;&gt; _GetGameObjectsInScenes()
		{
			var sceneCount = EditorSceneManager.sceneCount;
			var gameObjectsInScenes = new Dictionary&lt;Scene, HashSet&lt;GameObject&gt;&gt;();
			for( int i = 0; i &lt; sceneCount; ++i ) {
				var scene = EditorSceneManager.GetSceneAt( i );
				if( scene.isLoaded ) {
					gameObjectsInScenes.Add( scene, _GetGameObjectsInScene( scene ) );
				}
			}

			return gameObjectsInScenes;
		}

		HashSet&lt;GameObject&gt; _GetGameObjectsInScene( Scene scene )
		{
			var gameObjects = new HashSet&lt;GameObject&gt;();
			var rootGameObjects = scene.GetRootGameObjects();
			foreach( var rootGameObject in rootGameObjects ) {
				if( rootGameObject != null ) {
					_GetGameObjectsInScenes( gameObjects, rootGameObject.transform );
				}
			}

			return gameObjects;
		}

		void _GetGameObjectsInScenes( HashSet&lt;GameObject&gt; gameObjects, Transform transform )
		{
			if( transform != null ) {
				gameObjects.Add( transform.gameObject );

				var childCount = transform.childCount;
				for( int i = 0; i &lt; childCount; ++i ) {
					_GetGameObjectsInScenes( gameObjects, transform.GetChild( i ) );
				}
			}
		}

		public void Add( GameObject gameObject )
		{
			if( gameObject != null ) {
				HashSet&lt;GameObject&gt; gameObjects;
				if( !_gameObjectsInScenes.TryGetValue( gameObject.scene, out gameObjects ) ) {
					gameObjects = new HashSet&lt;GameObject&gt;();
					_gameObjectsInScenes.Add( gameObject.scene, gameObjects );
				}

				_GetGameObjectsInScenes( gameObjects, gameObject.transform );
			}
		}

		public void Remove( GameObject gameObject )
		{
			if( gameObject != null ) {
				foreach( var gameObjectInScene in _gameObjectsInScenes ) {
					if( gameObjectInScene.Value.Remove( gameObject ) ) {
						gameObjectInScene.Value.RemoveWhere( g =&gt; g.transform.IsChildOf( gameObject.transform ) );
						return;
					}
				}
			}
		}

		public bool Contains( GameObject gameObject )
		{
			Scene tempScene;
			return _TryGetSceneFromGameObject( gameObject, out tempScene );
		}

		static bool _TryGetSceneFromGameObject( GameObject gameObject, out Scene scene )
		{
			if( gameObject != null ) {
				foreach( var gameObjectInScenes in _gameObjectsInScenes ) {
					if( gameObjectInScenes.Value.Contains( gameObject ) ) {
						scene = gameObjectInScenes.Key;
						return true;
					}
				}
			}

			scene = new Scene();
			return false;
		}

		public void CheckDeleted()
		{
			foreach( var gameObjectInScene in _gameObjectsInScenes ) {
				if( gameObjectInScene.Value.RemoveWhere( g =&gt; g == null ) &gt; 0 ) {
					_GameObjectDeleted( gameObjectInScene.Key );
				}
			}
		}

		public bool CheckSceneChanged()
		{
			bool changedAnything = false;

			for(;;) {
				bool removedAnything = false;
				foreach( var gameObjectInScene in _gameObjectsInScenes ) {
					if( !gameObjectInScene.Key.isLoaded ) {
						_gameObjectsInScenes.Remove( gameObjectInScene.Key );
						changedAnything = true;
						removedAnything = true;
						break;
					}
				}
				if( !removedAnything ) {
					break;
				}
			}

			var sceneCount = SceneManager.sceneCount;
			for( int i = 0; i &lt; sceneCount; ++i ) {
				var scene = SceneManager.GetSceneAt( i );
				if( scene.isLoaded &amp;&amp; !_gameObjectsInScenes.ContainsKey( scene ) ) {
					_gameObjectsInScenes.Add( scene, _GetGameObjectsInScene( scene ) );
					changedAnything = true;
				}
			}

			return changedAnything;
		}
	}

	class _GameObjectSiblings
	{
		List&lt;GameObject&gt; gameObjects = new List&lt;GameObject&gt;();
		HashSet&lt;string&gt; names = new HashSet&lt;string&gt;();

		public Scene scene;
		public bool markNewInstanceAvailable = false;

		public _GameObjectSiblings( Scene scene )
		{
			this.scene = scene;
		}

		public _GameObjectSiblings( Scene scene, GameObject[] gameObjects )
		{
			this.scene = scene;
			Add( gameObjects );
		}

		public void Add( GameObject gameObject )
		{
			if( gameObject != null ) {
				this.gameObjects.Add( gameObject );
				this.names.Add( gameObject.name );
			}
		}

		public void Add( GameObject[] gameObjects )
		{
			if( gameObjects != null ) {
				foreach( var gameObject in gameObjects ) {
					Add( gameObject );
				}
			}
		}

		public bool Contains( GameObject gameObject )
		{
			if( gameObject != null ) {
				return this.gameObjects.Contains( gameObject );
			}

			return false;
		}

		public bool Contains( string name )
		{
			if( name != null ) {
				return this.names.Contains( name );
			}

			return false;
		}

		public void Remove( GameObject gameObject )
		{
			if( gameObject != null ) {
				this.gameObjects.Remove( gameObject );
				this.names.Remove( gameObject.name );
			}
		}
	}

	class _GameObjectHierarchy
	{
		Dictionary&lt;Scene, _GameObjectSiblings&gt; _rootSiblings = new Dictionary&lt;Scene, _GameObjectSiblings&gt;();
		Dictionary&lt;Transform, _GameObjectSiblings&gt; _siblings = new Dictionary&lt;Transform, _GameObjectSiblings&gt;();

		public _GameObjectHierarchy( GameObject[] selectionGameObjects )
		{
			// Note: Collect minimum siblings.

			_CollectSiblingsInScenes(); // for &quot;GameObject/Create Empty&quot;

			if( selectionGameObjects != null ) {
				foreach( var gameObject in selectionGameObjects ) {
					if( gameObject != null ) {
						_CollectSiblings( gameObject.transform ); // for &quot;GameObject/Create Empty Child&quot;
						_CollectSiblings( gameObject.transform.parent ); // for &quot;Edit/Duplicate&quot;
					}
				}
			}
		}

		public _GameObjectSiblings GetSiblings( GameObject gameObject )
		{
			_GameObjectSiblings siblings;
			if( gameObject != null ) {
				var parent = gameObject.transform.parent;
				if( parent == null ) {
					if( _rootSiblings.TryGetValue( gameObject.scene, out siblings ) ) {
						return siblings;
					}
				} else {
					if( _siblings.TryGetValue( parent, out siblings ) ) {
						return siblings;
					}
				}
			}

			return null;
		}

		public _GameObjectSiblings Move( _GameObjectSiblings siblingsFrom, GameObject gameObject )
		{
			if( siblingsFrom != null &amp;&amp; gameObject != null ) {
				siblingsFrom.Remove( gameObject );

				var siblingsTo = GetSiblings( gameObject );
				if( siblingsTo != null ) {
					siblingsTo.Add( gameObject );
					return siblingsTo;
				}

				if( gameObject.transform.parent != null ) {
					return _CollectSiblings( gameObject.transform.parent );
				} else {
					return _CollectSiblingsInScene( gameObject.scene );
				}
			}

			return null;
		}

		void _CollectSiblingsInScenes()
		{
			var sceneCount = SceneManager.sceneCount;
			for( int i = 0; i &lt; sceneCount; ++i ) {
				_CollectSiblingsInScene( SceneManager.GetSceneAt( i ) );
			}
		}

		_GameObjectSiblings _CollectSiblingsInScene( Scene scene )
		{
			if( scene.isLoaded ) {
				var siblings = new _GameObjectSiblings( scene, scene.GetRootGameObjects() );
				_rootSiblings.Add( scene, siblings );
				return siblings;
			} else {
				return null;
			}
		}

		_GameObjectSiblings _CollectSiblings( Transform parent )
		{
			if( parent == null ) {
				return null;
			}

			_GameObjectSiblings siblings;
			if( _siblings.TryGetValue( parent, out siblings ) ) {
				return siblings;
			}

			siblings = new _GameObjectSiblings( parent.gameObject.scene );
			for( int i = 0; i &lt; parent.childCount; ++i ) {
				siblings.Add( parent.GetChild( i ).gameObject );
			}
			_siblings.Add( parent, siblings );
			return siblings;
		}

		public void CheckSceneChanged()
		{
			for(;;) {
				bool removedAnything = false;
				foreach( var rootSiblings in _rootSiblings ) {
					if( !rootSiblings.Key.isLoaded ) {
						_rootSiblings.Remove( rootSiblings.Key );
						removedAnything = true;
						break;
					}
				}
				if( !removedAnything ) {
					break;
				}
			}

			for(;;) {
				bool removedAnything = false;
				foreach( var siblings in _siblings ) {
					if( !siblings.Value.scene.isLoaded ) {
						_siblings.Remove( siblings.Key );
						removedAnything = true;
						break;
					}
				}
				if( !removedAnything ) {
					break;
				}
			}

			var sceneCount = SceneManager.sceneCount;
			for( int i = 0; i &lt; sceneCount; ++i ) {
				var scene = SceneManager.GetSceneAt( i );
				if( scene.isLoaded &amp;&amp; !_rootSiblings.ContainsKey( scene ) ) {
					_CollectSiblingsInScene( scene );
				}
			}
		}
	}
}

}
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2020, All Tool Manual.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>