91-00
=============================

91. K-meansによる減色処理 (Step.1) 色の距離によるクラス分類
----------------------------------------------------------------

imori.jpgをK-meansを用いた減色処理

減色処理はQ.6でも扱ったが、Q.6では予め決めた色に減色した。
ここで扱うのはK-meansを用いて動的に減色する色を決定する。

アルゴリズムは,

1. 画像からランダムにK個のRGB成分をサンプリングする。（これをクラスと呼ぶことにする。）

2. 画像のそれぞれの画素に対して色の距離が最小となるクラスのインデックスを割り振る。

色の距離 dis = sqrt( (R-R')^2 + (G-G')^2 + (B-B')^2)

3. 各インデックスに対応する色成分の平均をRGBそれぞれに対して取り、新たなクラスとする。

4. 元のクラスと新しいクラスが全く同じならK-meansを終了する。そうでなければ、新しいクラスを元クラスとして2-3を繰り返す。

5. 元画像の各画素で色の距離が最小となるクラスのRGBを割り当てる。

1-2を実装

- クラス数はk=5とする

- ここでは画像をreshape((HxW, 3))にreshapeすると扱いやすくなる。
- 1においてはnp.random.seed(0)として、np.random.choice(np.arrange(画像のWxH), 5, replace=False)
- まずは3-5のループを考えずに実装せよ

.. code-block:: python

    # 最初に選べれた色
    [[140. 121. 148.]
     [135. 109. 122.]
     [211. 189. 213.]
     [135.  86.  84.]
     [118.  99.  96.]]

最初に選ばれた色との色の距離でクラスのインデックスをつけたもの(アルゴリズム2)。
解答では0-4にインデックスの値をx50にして見やすいようにしている。

.. toctree::
   code/answer_91

Q.92. K-meansによる減色処理 (Step.2) 減色処理
----------------------------------------------

ここではアルゴリズム3-5も実装せよ。

.. code-block:: python

    # 選ばれた色
    [[182.86730957 156.13246155 180.24510193]
     [156.75152588 123.88993835 137.39085388]
     [227.31060791 199.93135071 209.36465454]
     [ 91.9105835   57.94448471  58.26378632]
     [121.8759613   88.4736557   96.99688721]]


減色処理したもの。塗り絵イラスト風な画像にできる。k=10にすればある程度の色を保持しながらもイラスト風に減色できる。

また、k=5にしてmadara.jpgにも試してみよ。


.. toctree::
   code/answer_92

Q.93. 機械学習の学習データの用意 (Step.1) IoUの計算
------------------------------------------------------

ここから機械学習で用いる学習データの準備を行う。

最終的にはイモリの顔か否かを判別する識別器を作りたい。
そのためにはイモリの顔の画像とイモリの顔以外の画像が必要になる。
それらを用意するためのプログラムを作成する。

そのためにはイモリの顔周辺を一枚の画像から切り抜く必要がある。
そこで一つの矩形を設定して(GT: Ground-truth, 正解と呼ぶ)、
ランダムに切り抜いた矩形がGTとある程度重なっていれば、イモリの顔となる。

その重なり具合を計算するのが、IoU: Intersection over unionであり、次式で計算される。

ここでは、以下の２つの矩形のIoUを計算せよ。

.. code-block:: python

    # [x1, y1, x2, y2] x1,y1...矩形の左上のx,y  x2,y2...矩形の右下のx,y
    a = np.array((50, 50, 150, 150), dtype=np.float32)

    b = np.array((60, 60, 170, 160), dtype=np.float32)

.. toctree::
   code/answer_93

Q.94. 機械学習の学習データの用意 (Step.2) ランダムクラッピング
---------------------------------------------------------------

次に、imori_1.jpgからランダムに画像を切り抜いて(cropping, クラッピングと呼ぶ)学習データを作成する。

ここでは画像から60x60のサイズの矩形をランダムに200個切り抜け。

ただし、以下の条件を満たせ。

1. np.random.seed(0)として、切り抜く矩形の左上のx1 = np.random.randint(W-60),
y1=np.random.randint(H-60)で求めよ。
2. GT (gt = np.array((47, 41, 129, 103),
dtype=np.float32))とのIoUが0.5以上の時はその矩形に教師ラベル1, 0.5未満の場合はラベル0を与えよ。

答えは、ラベル1の矩形を赤、ラベル0の矩形を青、GTを緑にしている。

これでイモリの顔の画像、それ以外の画像を簡易的に用意できた。




.. toctree::
   code/answer_94

.. toctree::
   code/answer_95

.. toctree::
   code/answer_96

.. toctree::
   code/answer_97

Q.98. 簡単な物体検出 (Step.2) スライディングウィンドウ + NN
---------------------------------------------------------------

NMS: Non-maximum suppressionという手法を用いて矩形の数を減らす。

NMSとはスコアの高いBounding-boxのみを残す手法であり、アルゴリズムは以下の通り。

Boundinb-boxの集合Bをスコアが高い順にソートする。
スコアが最大のものをb0とする。
b0と他のBounding-boxのIoUを計算する。IoUが閾値t以上のBounding-boxをBから削除する。
B0は出力する集合Rに加え、Bから削除する。
2-3をBがなくなるまで行う。
Rを出力する。

Q.98にNMS(閾値t=0.25)を組み込み、出力を描画


.. toctree::
   code/answer_98

.. toctree::
   code/answer_99

.. toctree::
   code/answer_100
