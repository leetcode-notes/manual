

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>forgamer 西川善司連載完全理解「3DMarkVan &mdash; All-Tool-Manual 0.00 ドキュメント</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/showreel.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="../../../../genindex.html"/>
        <link rel="search" title="検索" href="../../../../search.html"/>
    <link rel="top" title="All-Tool-Manual 0.00 ドキュメント" href="../../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> All-Tool-Manual
          

          
          </a>

          
            
            
              <div class="version">
                0.00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../CPlus/CPlus.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Csharp/csharp.html">C#</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Render/Rendaring.html">Rendaring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ZScript/Zscript.html">ZScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../algorithm/algorytm.html">algorytm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bat/cmd.html">cmd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../game/game.html">game memo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../git/git.html">git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../houdini/houdini.html">Houdini</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../javascript/javascript.html">javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../linux/linux.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../maya/maya.html">maya Tool manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindmap/mindmap.html">manual mindmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../shader/shader.html">shader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../shotgun/shotgun.html">Shotgun manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/com.html">tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../web/web.html">web application framework etc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">All-Tool-Manual</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
    <li>forgamer 西川善司連載完全理解「3DMarkVan</li>
    <li class="wy-breadcrumbs-aside">
      
          <a href="https://github.com/paste/game/西川善司/forgamer/西川善司連載完全理解「3DMarkVan.rst" class="fa fa-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="forgamer-3dmarkvan">
<h1>forgamer 西川善司連載完全理解「3DMarkVan<a class="headerlink" href="#forgamer-3dmarkvan" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>西川善司連載 / 完全理解「3DMark Vantage」（1）グラフィックスエンジン・前

西川善司の3Dエクスタシー　完全理解「3DMark Vantage」（1）グラフィックスエンジン・前

次回のページへ

　3DMark Vantageがついにリリースされた。



　Windows Vista専用で，DirectX 10世代プログラマブルシェーダ4.0仕様（Shader Model 4.0，以下SM4.0）のGPUが必須というシステム要件については2008年4月28日の記事で伝えられているとおりだが，最新世代の3Dゲームタイトルが，次第にWindows Vista環境を想定してきていることを考えると，筆者個人としては妥当な判断だと思う。



　これまでの3DMarkシリーズと同様，今回も「Futuremarkが考えた」という留保は与えられるものの，「次世代3Dゲームのグラフィックス処理やCPUオペレーションはこうなる」という想定のもと，3DMark Vantageは開発された。本連載では以後数回に亘（わた）って，同ベンチマークアプリケーションの技術的解説を行っていき，Futuremarkの考えに迫ってみたいと考えている。



　第1回となる本稿では，3DMark Vantageのホワイトペーパーを基に，同アプリケーションのグラフィックスエンジンについて見ていくことにしたい。



 



 



3DMark Vantageにおける3Dエンジンの流れ

 



　まず，大まかなエンジンの流れだが，以下の6ステップからなるとFuturemarkは説明している。



GPUによるシミュレーションパス

影生成のためのシャドウマップ生成パス

先行Zバッファレンダリング

不透明材質のライティング

透明/半透明材質のライティング

ポストプロセス

　それぞれについて，踏み込んで解説してみることにしよう。



 



1.GPUによるシミュレーションパス

　3DMark Vantageでは一部のシミュレーション計算を，CPUではなくGPUで行っている。そして，GPUを利用したシミュレーションは，頂点シェーダ（Vertex Shader）やジオメトリシェーダ（Geometry Shader）を活用した頂点レベルのシミュレーションと，ピクセルシェーダ（Pixel Shader）を活用したテクスチャレベルのシミュレーションとに大別できる。



 



●頂点レベルのシミュレーション



　頂点レベルのシミュレーションは，「Graphics Test 1: Jane Nash」における水陸両用機にかけられた布，あるいは「Feature Tests: Cloth Simulation Test」の旗などが代表例だ。

　頂点レベルのシミュレーションでは，DirectX 10パイプラインで新設されたストリームアウト（Stream Out）の機能を活用しているという。ストリームアウトとは，頂点シェーダからの出力をバッファに書き出し，再び頂点シェーダに戻すことができる機能のことで，3DMark Vantageではこの機能を使い，頂点シェーダが行ったシミュレーション結果を再び頂点シェーダに戻して，今度はこれを基にして速やかにグラフィックス処理へ取りかかれるようにしている。

　ちなみにDirectX 9世代のプログラマブルシェーダ3.0（Shader Model 3.0，以下SM3.0）仕様には，この機能はなかったので，いったん頂点シェーダユニットで出力した内容を，必ず一度ピクセルシェーダユニットのパイプラインを経てから頂点シェーダユニットへ戻す処理が必要だった。



 



imageimage

Jane Nashデモにおける布のシミュレーションはGPUで行われている



 



image

水しぶきのような一部のパーティクル制御も，GPUによるシミュレーションによるもの



　そのほか，火花や水しぶき，塵（ちり）のようなパーティクルに対するシミュレーションも頂点シェーダによって行われている。パーティクルに対するシミュレーションは3Dゲームグラフィックスでよく用いられるベルレ積分法（Verlet Intergration）が利用されているとのこと。ベルレ積分は「前の状態と現在の状態の差分情報から次状態のベクトルを算出する」離散的な積分方法で，GPUで処理するのに向いている。



 



image

MicrosoftのDirectX 10デモより。DrawAuto機能とジオメトリシェーダを活用し，GPU処理だけで花火パーティクルを打ち上げ続けるサンプルが用意されている



　なおFuturemarkは，DirectX 10の新機能である「DrawAuto」は使用しなかったとしている。DrawAutoとは，CPU側のエンジン処理と非同期で，GPU内部で描画を勝手に開始してしまう機能で，CPUに“お伺い”を立てることなく，必要な情報さえ揃っていればGPU側で自動描画してしまえるので，処理の高速化に結びつく。しかし，3DMark Vantageのエンジンでは，シミュレーション処理後のパーティクルの状態をCPU側（＝エンジン側）で保存，参照する設計になっているため，描画後はCPU（＝エンジン）に結果を返す必要がある。そのため，CPUと非同期でGPUが勝手に処理を進めてしまうDrawAutoは逆に不都合だったというわけだ。

　もっともFuturemarkは，「CPU側が関知する必要のない，例えば『火のパーティクルから出た火の粉』のような孫階層のパーティクルなら，DrawAutoを活用するのは面白いかもしれない」とも述べており，将来的に同機能を採用する可能性に含みを持たせている。



 



●テクスチャレベルのシミュレーション



　さてもう一つ，テクスチャレベルのシミュレーションは主に，水面における波の動きを生成するために用いられている。「テクスチャがなんで波の動きになるの？」という疑問が浮上するかもしれないので，少し確認しておこう。



 



image

image

水面の波は，GPUを使ったテクスチャレベルのシミュレーションによって生成されている



　そもそも「テクスチャ」と聞くと画像のイメージを持ちやすいが，プログラマブルシェーダ時代においては，PCにおけるメインメモリというか，配列データの格納場所として活用されることが多い。それこそ「水面の立体的な凹凸」としての波を生成するときには，複数のテクスチャを「シミュレーション用のワークバッファ（作業用記憶領域）」として活用するのだ。

　水面を表現する場合は，テクスチャに波の凹凸情報などが格納（＝記録）される。そしてピクセルシェーダ（として起用されたストリーミングプロセッサ）は，このテクスチャに対して波動シミュレーションを適用し，次の水面の凹凸状態を算出。その結果を基に，後のパスで当該テクスチャに記録された凹凸情報を実際の水面ポリゴン上の頂点に適用して摂動（※力学用語で，多方向かつさまざまな大きさのベクトルが混ざった動きのこと）させ，ジオメトリレベルでの凹凸に変換するのである。



　GPUに詳しい読者のなかにはピンときた人も多いだろうが，これは，テクスチャ情報をもとに頂点情報を変調する，頂点テクスチャリング（Vertex Texture Fetching，以下VTF）の処理だ。DirectX 9時代はNVIDIAのGPUにしか実装されなかったVTFだが，統合型シェーダ（Unified Shader）アーキテクチャが当たり前のDirectX 10世代では，すべてのGPUが対応している。だから，DirectX 10専用の3DMark Vantageは積極的に活用しても問題がないというわけ。

　なお，3DMark Vantageにおけるテクスチャレベルのシミュレーションでは，PCの性能にかかわらず一定の内容が実行される。つまり，高速なPCなら短時間で，低速ならより時間をかけて処理されるという違いはあるが，実行されるシミュレーションの過程も結果も同じ（※というか，変わってしまったらベンチマークテストにならない）ということだ。



 



image

　また，布や水面など一部のシミュレーションでは，当該シーンをレンダリングした後の深度値（＝Zバッファの内容）を参照することで，シミュレーション対象物とシーン内の動的オブジェクトの衝突判定を行い，オブジェクトの挙動を再現（あるいは表現）しているという。



 



2.影生成のためのシャドウマップ生成パス

　3DMark Vantageの影生成法は，「3DMark06」と同型の「デプスシャドウ」（Depth Map Shadow）技法が採用された。影の生成元の光源位置からZバッファレンダリングを行って，光源からの奥行き情報（深度情報）を「シャドウマップ」（Shadow Maps）として生成し，視点からのシーンをレンダリングするときには，「視点からのシーンの奥行き情報とシャドウマップを吟味して影か否かの判断をしつつ，各ピクセルについてライティングを行う」影生成技法になる。実在の3Dゲームにおいても影生成の主流はデプスシャドウ技法になっているため，この選択は妥当といえるだろう。



 



image

3DMark05より。デプスシャドウ技法では，こんな感じで，影の輪郭がけば立つようなエイリアシングが出やすい。最近はデプスシャドウ技法の採用が多いため，PCだけでなくPLAYSTATION 3やXbox 360のタイトルでもこうした影はよく見られる



　ちなみに本技法は「シーンの遮蔽構造であるシャドウマップを生成する」という技法的特徴から「シャドウマップ」技法と呼ばれることもある。3DMark Vantageでは，通常シーンのレンダリングの前に，このシャドウマップ生成を行っているという。



 



　さて，デプスシャドウ技法では，そのシーンに対する光の遮蔽構造をシャドウマップが把握することになるため，セルフシャドウや相互投射影などといったあらゆる影生成を行えるのだが，シャドウマップ解像度を高く取っておかないと，生成した影にエイリアシング（＝ジャギー）が強く出るという弱点も併せ持っている。この弱点を克服するためにさまざまな改良版技法が考案されつつあるというのが，3DMark Vantageのリリースされた今日（こんにち）の状況だ。



　3DMark Vantageでは，このデプスシャドウ技法の改良版である二つの技法が実装されている。一つは「近傍フィルタ処理付きカスケード・シャドウマップ」，もう一つは「バリアンス・シャドウマップ」だ。



 



●近傍フィルタ処理付きカスケード・シャドウマップ



　近傍フィルタ処理付きカスケード・シャドウマップ（Percent Closer Filtering on Cascaded Shadow Maps。以下，PCF付きカスケード・シャドウマップ）は3DMark06で採用された技法で，3DMark Vantageでもほぼ同じものが実装されている。PCF付きカスケード・シャドウマップについては，筆者連載のバックナンバー「3DMark06の秘密 第2回『3DMark06で学ぶ影生成事情』」で詳しく解説しているので，興味を持った人はそちらを参考にしてほしい。



 



imageimage

PCF付きカスケード・シャドウマップはGraphics Test 1: Jane Nashで活用されている。ホバークラフトを覆うカバーやコンテナの影に，目立ったエイリアシングが見受けられない点は要注目だ。スカートのセルフシャドウもバッチリ！



 



image

余談だが，PCF付きカスケード・マップ技法はカプコンの「ロスト プラネット エクストリーム コンディション」にも採用されている。画像は同タイトルにおけるカスケード・シャドウマップのイメージ（※連載バックナンバー「カプコンに聞く『ロスト プラネット』のグラフィックスオプション」より再掲）



　念のため簡単に説明しておくと，デプスシャドウ技法のように，シャドウ解像度を“ムダに”高くするのではなく，適当な解像度のシャドウマップを複数用意し，視点の近いところから遠いところまでの影生成をこれらでカバーするというテクニックになる。シャドウマップをカスケードさせて（≒段階的に配置して）レンダリングするカスケード・シャドウマップ技法というわけだ。

　そして，シャドウマップを参照した「影か否か」の判定に当たって，判断対象点の周囲にある複数点をサンプルして処理するのがPCFになる。このPCF処理におけるサンプル数の大小は3DMark Vantageの設定オプション「OPTIONS」にある「SHADOW SHADER QUALITY」の「Entry / Performance / High / Extreme」から4段階に指定できることになっているが，各設定がそれぞれ何サンプルなのか，内訳は明らかにされていない。



 



●バリアンス・シャドウマップ



　二つめの影生成技法となるバリアンス・シャドウマップ（Variance Shadow Maps。以下，VSM）は，Unreal Engine 3にも採用されている技法で，こちらは「Graphics Test 2: New Calico」で活用されている。

　「シャドウマップを生成し，これを参照して『影か否か』を判断しながらシーンをレンダリングしていく」という大まかな流れはデプスシャドウ技法と同じ。しかし，デプスシャドウだとこの「影か否か」を「Yes」「No」の二値判定するのに対して，VSM技法では確率論で用いられる「チェビシェフの不等式」（Chebychev’s Inequalities）を用いて，「光が当たっている最大確率」を算出して行うのだ。



　チェビシェフの不等式は，次のとおり表される。



 



P(x≧t)≦	σ2



σ2+(t-E(x))

 



　これは「分散σ2と平均値E（x）のデータがあるときに「x≧t」となる確率Pの最大値を求める」不等式だ。

　デプスシャドウ技法において，「シャドウマップに記録されている値（＝遮蔽物から光源までの距離）」＞「レンダリングしようとしているピクセルから光源までの距離」となったときには光が当たっていると判断できる。つまり，求めたい確率「P（x≧t）」において，tを「レンダリングしようとしているピクセルから光源までの距離」としてこの不等式を活用すると，確率P（x≧t）は「光が当たっている確率」に相当するというわけである。

　なお，分散σ2は以下のように表され，平均値E（x）はシャドウマップに記録されている値を用いて計算される。



 



σ2=E(x2)-E(x)2



 



image

一般的なデプスシャドウ技法（左）とVSM技法（右）の違い



　確率は0～1の範囲で表されるため，そのまま影の色（＝影の濃さ）として利用できる。影の本体に近ければ近いほど影となる確率が高くなって影の色は濃くなり，逆に影の輪郭から遠くなればなるほど影の確率が下がって影の色は薄くなる。結果として，影の輪郭付近がグラデーションのようになり，ソフトシャドウ的な表現になるのだ。もちろん，物理的に正しいソフトシャドウではないが，“見た目的”には十分な妥当性がある。



 



imageimage

明部分に向かって影の消失していく流れが自然に見えることもあって，ライティング結果の「陰」とセルフシャドウの「影」との区別がつきにくいVSMのシャドウ。“お手軽ソフトシャドウ技法”として実際の3Dゲームでも採用例が後を絶たない



 



3.先行Zバッファレンダリング

 



　3Dグラフィックスでは，そのピクセルを描画してもいいかどうかの判断に当たって，Zバッファに記録された深度値を参照する。Zバッファには最後に書き込まれた「ピクセルの視点から見た奥行き情報（＝深度値）」が書き込まれていて，これから描画しようとするピクセルの深度値が，Zバッファ上の深度値より奥側ならば，「すでに描かれているピクセルのほうが視点から見える」ため破棄される。逆に，Zバッファ上の深度値よりも手前ならそのピクセルは描かれることになるわけだが，このときよく考えると，先に書き込まれていたピクセル（＝新しいピクセルよりも奥側にあったピクセル）はムダになる。つまり，当該ピクセルのために費やされた計算時間はムダだったことになってしまう。



 



image

 



　高度なピクセルシェーダプログラムを動かしていればいるほど，このムダな時間は重くのしかかってくる。最新のリアルタイム3Dグラフィックスでは，長大で複雑なピクセルシェーダプログラムを動かすことが多くなってきているため，「描いたピクセルが実はムダだった」というのは演算リソースの深刻なムダ遣いとなるのだ。



　そもそもピクセル描画とZバッファ更新を同時にやっているからこういう無駄が起こる。ならばピクセルシェーダプログラムを動かさず（＝ピクセル描画を行わず），先にそのシーンの最終的な深度情報を作り上げてしまい，その結果を用いれば，上書きされて無意味になってしまうピクセルの描画は行わずに，実際に有効となるピクセルのみについて複雑なピクセルシェーダプログラムを動かして描画できることになるではないか。

　3DMark Vantageのエンジンでは，そんな「先行Zバッファレンダリング」のテクニックを実装している。



 



image

 



　まあ，先行Zバッファレンダリング時も，後段となる通常レンダリング時も，ジオメトリなどの一部の計算処理は重複して行われることになってしまうので，まったくムダがないかというとそうでもないが，ピクセルシェーダ負荷のほうが明らかに高くなると予見できるグラフィックス設計では有効なメソッドだ。実際，最近の3Dゲームエンジンでも採用されつつある。



 



4.不透明材質のライティング

 



image

3DMark VantageのライティングはHDR次元で行われている



　「不透明材質」というとなにやらイメージしにくいが，要するに，透けて見える透明/半透明な材質以外の通常のものをライティングするプロセスである。

　3DMark Vantageでは，このライティングプロセスにおいて，最新トレンドに則ったハイダイナミックレンジ（High Dynamic Range。以下，HDR）レンダリングを実装している。各αRGBが16bit浮動小数点（FP16）のレンダーターゲットを採用しているとのことだ。3DMark06の頃からFP16-64bitバッファを活用していたので，劇的な進化があったわけではないが，逆に考えれば「3Dゲームグラフィックス用途のHDRレンダリングなら，FP16-64bitバッファのレンダーターゲットで必要十分である」とはいえるかもしれない。



 



image

ヘルメット上の映り込んだ照明がブルームを起こしている点に注目。3DMark Vantageでは環境マップもHDR次元だ



　キューブマップや環境マップテクスチャについてもHDRのFP16-64bitフォーマットを採用しており，HDR次元のレンダリング（＝ライティング）が行えるようになっている。

　デカールテクスチャ（＝画像テクスチャ）などは各αRGBが8bitの32bitフォーマットを採用しているが，格納値はsRGB値から線形値に変換されているとのこと。詳しくは言及されていないが，HDRレンダリングパスと迎合させるために共通指数項やHDRスケール値をα値などに入れて，計算時には32bitバッファをFP16のHDR次元に変換するような仕組みを取り入れているのかもしれない。



 



5.透明/半透明材質のライティング

 



image

image

3DMark Vantageの半透明オブジェクトには，水しぶきのようなパーティクル関係が多い



　透明/半透明材質のライティングは，3Dグラフィックスにおいて，一筋縄では行かない面倒なテーマだ。

　基本的に透けて見えるので，深度値を使った「カリング」――前述した，描画不要なピクセルを破棄する処理――が役に立たない。そのため，不透明材質をレンダリングし終えてから行うことになっているのである。



　3DMark Vantageでの透明/半透明材質は主に火花，煙，水しぶきなどのパーティクル関係が多いようだ。

　パーティクルと不透明の通常材質シーンとの合成では，パーティクルと通常材質背景との境界線が露呈しないようにする「ソフトパーティクル」（Soft ParticleあるいはSoft Clipping）処理が行われている。これも，最近の3Dゲームグラフィックスでは採用が当たり前となりつつあるテクニックだ。本連載では「Call of Duty 2」のグラフィックスオプション解説時に取り扱ったことがあるが，最も基本的なのは「パーティクルのピクセル描画に当たって，当該シーンの深度値とピクセルの深度値を比較して，その交差線に向かって透明度を上げていく」手法である。



 



●3DMark Vantageにおけるシェーダの仕様



　透明/半透明材質のライティングに関連して，3DMark Vantageに用いられているシェーダの仕様についても言及しておこう。

　3DMark Vantageにおけるシェーダプログラムは大まかに三つのタイプ，材質シェーダ（Matreial Shader），ライティングシェーダ（Light Shader），座標変換シェーダ（Transformation Shader）に分かれるとFuturemarkは説明する。



 



image

　材質シェーダは，衣服や岩，金属，肌，樹脂といった，表現する材質ごとの反射モデルをシェーダプログラム化したものに相当する。発光する材質もこの材質シェーダの類だ。

　ライティングシェーダは，「材質シェーダが処理を行う対象ピクセルに，光源からの光がどのように注がれるのか」を処理するシェーダだ。現在のシェーダプログラムの仕様では，点光源，並行光源といったように光源の種類が変わったり，あるいは光源の数が変わったりしたときに，光源状況に応じたシェーダプログラムを用意しなければならない。この要請へ柔軟に対応するための仕様と思われる。



 



imageimage

ジャケットにはフレネル反射付きのライティングが行われたり，眼球内には情景が映っていたりと，Jane Nashでは相応にリッチなシェーダが動いている様子。わざとらしいほどの透明感を持った彼女の肌には，もしかすると簡易的なスキンシェーダも実装されている？　深度値を活用して厚みを算出し，これを基に擬似的な表面下散乱シェーダを実現するのは，3DMark06の水棲怪物で実績があるだけに，何かやっているのかも？



 



　座標変換シェーダは，主に頂点シェーダが行う座標系の変換処理を行うものになる。ボーン（＝骨格）の変形により表皮ポリゴンがどのように変形するかの処理を行うスキニング処理なども，この座標変換シェーダの部類に属する。



 



imageimage

ボーンスキニングは頂点シェーダのお仕事



 



　3DMark Vantageのエンジンにおいて，材質シェーダとライティングシェーダはHLSL（High-Level Shader Language，上位レベルシェーダ言語）で書かれた断片ソース（＝テキストベース）で管理されている。

　そしてエンジンの実行開始時には，そのシーンで必要とされる材質シェーダ部品と，そのシーンで用いられる光源の種類と数に応じて適切なライティングシェーダ部品をかき集め，「1本の完成されたシェーダプログラムのテキストファイル」として合成する処理が行われる。つまり，エンジンが最初にシェーダプログラムのテキストファイルを調合しているわけだ。合成したシェーダプログラムはコンパイルされ，実行形態に変換される。テスト読み出し中の画面で，インジケータに「Creating Shaders」と表示されるが，これが，シェーダプログラムのテキストファイルを合成してコンパイルしているフェーズである。



　シェーダプログラムはGPU側に転送されないと実行できないため，実際に3DMark Vantageデモシークエンスの描画が始まる前には，コンパイルされて生成されたシェーダコードをシステムキャッシュに読み込ませたり，GPUに転送したりするエンジンのウォームアップが行われる。

　シェーダプログラムはDirectX 10/SM4.0なので，同種の光源が複数ある場合は，その光源の分だけループして，材質シェーダのサブルーチンをコールする。異なる種類の光源が複数ある場合は，適切なライティングシェーダと材質シェーダを組み合わせて1本の長いシェーダプログラムとして構成し，シングルパスとして実行する。

　実質的に，シェーダプログラム長の制限がなくなったDirectX 10/SM4.0の特性を活用したエンジン/シェーダ設計がなされているわけだ。テストされるGPUの立場から見れば，ループ実行や長いシェーダプログラムの実行を試されることになる。



 6.ポストプロセス

　ポストプロセス（Post Process）は，直訳すれば「後処理」だが，3Dグラフィックスでは「レンダリング結果としての2Dフレームに対し，画像処理を行うこと」を指すことが多い。デジタルカメラで撮影した写真に対しては，フォトレタッチソフトなどを用いて色味を補正したり，輪郭を強調したり，赤目修正を行ったりするものだが，3Dグラフィックスにおけるポストプロセスは，この作業とよく似ている。ポストプロセスとは「ピクセルシェーダを使ったレタッチである」といってもいいだろう。



　フォトレタッチがそうであるように，ポストプロセスも悪くいえば「インチキ臭いフェイク処理」なのだが，実のところ，昨今の3Dゲームグラフィックスにおいては，このポストプロセスが重大なウェイトを占めている。そして，この流れを受け，3DMark Vantageでもかなりリッチなポストプロセスを実施している。個人的な感想を言わせてもらえば，ポストプロセス周りは，3DMark06と比べて，最も進化が著しい部分だと思う。



　3DMark Vantageにおいて目につく，代表的なポストプロセスを紹介していくとしよう。



 



●ブルーム（Bloom）



image

image

高輝度からふわーっとした光があふれ出ている感じの効果は，このブルームによるもの



　HDRレンダリングの醍醐味……というのは持ち上げすぎかもしれないが，HDRレンダリングのなかで，見た目的に最も分かりやすいのがブルームエフェクトだ。分かりやすくいえば，シーン中の高輝度部分があふれ出すようにして見える効果を指す。

　現実世界だと，このような光のあふれ出しは，「エアリーディスク」（Airy Disc）と呼ばれる，カメラや眼球のレンズ内回折現象によって引き起こされる。レンダリング結果に，普段見ている視界や写真に似せた，こうした効果をあえて加えることで，3Dゲームグラフィックスを，よりフォトリアル（＝写実的）に見せようというのが，このポストプロセスの意義になる。



　ブルーム効果のあふれ出しには，ボカしフィルタの定番であるガウスフィルタが用いられている。フォトレタッチソフトなどでも「ガウスフィルタ」（あるいは「ガウスボカし」）といったキーワードを見たことがあるかもしれない。



　実際の処理系としては，「シーンのレンダリング結果をテクスチャとして出力したもののうち，高輝度のピクセルに対してガウスフィルタを適用する」というアプローチになるのだが，一度ガウスフィルタを適用しただけではあふれ出しが不十分。そのため，3DMark Vantageでは，いわゆる「縮小バッファ」技法と呼ばれる，ブルームエフェクト実装法としてはスタンダードなテクニックが採用されている。

　これは，「シーンのレンダリング結果」の解像度を縦横半分（※0.5×0.5なので，面積比にして4分の1）にしてテクスチャに出力し，それに対して同じようにガウスフィルタを掛け，さらに縦横半分にして……と繰り返していくもの。最終的には，元のテクスチャと，4分の1サイズのボカし映像フレーム，16分の1サイズのボカし映像フレーム……といったように，解像度の異なるボカし映像フレームが複数枚出来上がる。



 



imageimageimage

imageimageimage

基になるシーン（※ここでは分かりやすくするため，緑の円にした。左上）があって，解像度を4分の1にしながら，ガウスフィルタをかけていく



 



　この状態で，解像度（≒サイズ）の下がっているフレームを，元のサイズにまで拡大してから1枚に合成してやるのだ。解像度を下げた，すなわち縮小したフレームに対して処理を行うから「縮小バッファ」技法というわけである。



 



imageimageimage

imageimageimage

今回は5パターン用意したが，ガウスフィルタを適用した状態で解像度を元に戻して（＝拡大して）合成する。すると右下のように，ブルーム効果のあふれ出しが自然に見えるというわけ。これは川瀬正樹氏がCEDEC 2002やGDC 2004で発表したことで広く活用されるようになった，いわば日本発のテクニックだ



 



　解像度を下げたフレームに対してボカしを適用し，それを合成時に拡大すると，同じボカし処理を繰り返しただけなのに，広範囲をボカしたのとほぼ同じ結果になる。もちろん，合成時に拡大する以上，場合によってはモザイク状の疑似輪郭が現れてしまうものの，合成時に，解像度の低いボカし結果ほど“薄く”して合成するので，そのアラは分かりにくくなり，まず問題ないとされている。

　なお，「どの輝度値からブルームを起こさせるのか」という閾（しきい）値の設定は，そのシーンを作り込んだアーティストが任意に設定できるようになっており，3DMark Vantageでどういった閾値設定がなされているかは明らかになっていない。



 



●光芒（Streaks）



　光芒は，高輝度部分のあふれ出させ方が少々違うだけで，基本的には前段のブルームと同種のエフェクトと考えていい。ブルームではもやーっとした，光のモヤのようなあふれ出しになるが，光芒は光が鋭く放射状に溢れ出すことを指す。星のマークはよく「★」の形で描かれるが，これは地球上から見たときに光の点でしかない星を見たとき，人間の睫毛やカメラレンズ内の絞り羽根における回折で，放射状に伸びた光筋に見える現象を端的に表したものだ。



 



imageimage

3DMark Vantageにおいて，光芒は6方向に光筋がはみ出すようなフィルタカーネルで処理されている。高輝度から六本の光筋が伸びるあふれ出し表現は，このポストプロセスによるものと考えていい



 



　3DMark Vantageでは，この光芒効果も（先ほどのブルームと同じく）縮小バッファ技法で実装している。

　シーンをテクスチャへレンダリングし，その高輝度部分だけを抽出しつつ解像度を下げたものを生成。これに対して32点サンプリングを行い，6方向へ放射状に光が伸びる加工を施してやる。本処理1回分だけでは光筋の伸びが不十分なので，解像度をさらに下げ手同様の処理を繰り返していく，という流れだ。



　複数の解像度を段階的に低くして生成した光芒効果フレームを，「解像度の低いものほど薄くブレンドする」ルールですべて合成。すると，中央は明るいが，中心から遠くに行けば行くほど淡くなる光芒が完成する。



 



●歪形フレア（Anamorphic Flare）



image

中央よりやや下に見える，青い横方向の鋭い光のあふれ出しが歪形フレアだ



　歪形フレアとは，カメラのレンズへ光源が直射した場合などに，水平方向に長く伸びる光芒のこと。実装形態は前述の光芒と同じだが，光が伸びるにつれて伸びた光の色がだんだんと変わっていく，「カラーシフト」を起こさせる処理が加わっている。これは，レンズで分光現象が起きているような見た目の印象を作り出してくれている。



 



●レンズフレア（Lens Flare）



　レンズフレアも，高輝度な情景をカメラが捉えたときにレンズ内反射で起きる虚像現象の一種。撮影映像のような雰囲気を出そうという狙いから，これをあえて付加するのだ。



　レンズフレア効果の実現に当たっては，「適当なボケ形状パターンをスプライトで表現し，これを放射状に配置する」という疑似的な手法もあるが，3DMark Vantageではポストプロセスで付加する方法を採用している。

　具体的には，「レンダリング結果フレームを縮小バッファの要領で縮小してボカし，さらに最外周を暗くする『ビネット効果』（Vignette Effect）も施して，これを画面中心から放射状に並べる」感じだ。



 



imageimage

3DMark Vantageにおけるレンズフレア実装がよく分かるショット2点。左では，台形状になった通路の高輝度部分の虚像がダブってその通路に上書きされているように見えるのが分かるだろうか。さらにその左にうっすらと台形の天地が逆転した虚像も見える。右は，太陽の虚像が左上方向に伸びている



 



●レンズ形状光輪（Lenticular Halo）



image

image

高輝度部分の外周へ，円状に分光するようにあふれ出すのがレンズ形状光輪



　レンズ形状光輪は，レンズフレアの一種で，「ハレーション」とも呼ばれることもある効果のこと。高輝度なものをカメラレンズで捉えたときに，その高輝度部分の外周に光の輪（＝Halo）が現れる現象を指す。

　これも基本的には前述したブルーム効果の別バージョンという感じの処理で，3DMark Vantageではシーンをテクスチャにレンダリングしたものを縦横4分の1，面積比で16分の1に縮小し，これにフィルタを適用するという流れになる。



　そのフィルタは，球形状に高輝度部分がはみ出していくものになるが，3DMark Vantageでは“光学現象っぽさ”を出すため，高輝度部分を円周状に広げてスライドさせていくときに色も変化させていく，カラーシフトの効果を織り交ぜている。こうすることで歪形フレアの場合と同様，光がレンズの影響で分光しているような味わいが生まれる。

　ただし，そのまま元フレームに合成したのでは，光輪が，適当な数のピクセルサンプルから作られている感じが露呈してしまう。そのため，ガウスブラーを適用してボカし，光が広がった雰囲気を出している。



 



●被写界深度（Depth of Field）



image

中央の戦闘機にフォーカスが合っているため，手前の1機と奥の2機はボケて見える



　被写界深度のシミュレーションも，最近の3Dゲームグラフィックスでは当たり前のように採用されつつある効果だ。簡単にいえば，「そのシーンをカメラで捉えたときのように見せる加工処理」になる。

　具体的には，フォーカス（＝ピント）が合っているところはキッチリと見せ，ピントがズレていく箇所については，そのピントのズレの大きさに応じてボカしていく。



　3DMark Vantageでの被写界深度効果は，オーソドックスな深度情報を用いたテクニックで実現されている。

　まず，通常どおりレンダリングしたシーン結果を各αRGB16bit整数のバッファ（int16-64bit）にコピーし，このときにフォーカス情報も（おそらくαに）埋め込んでしまう。一方，アーティストはカット割りごとの演出的なフォーカス位置をシーンの奥行き情報，すなわち深度値で設定している。つまり，通常レンダリングしたシーンにおける各ピクセルの深度値と，そのフォーカス深度値の差分は，「当該ピクセルのピントがどのくらいズレているか」の情報に相当することになる。これがフォーカス情報となるわけだ。



 



image

手前の二人にフォーカスが合っているため，奥の通路がボケて見える。3DMark Vantageの被写界深度は弱めな感じ



　フォーカス情報とピクセルカラーがひとまとめになったバッファは，ここでも縮小バッファのテクニックを使って低解像度に変換される。そして，この縮小された低解像度バッファに対して「適当なボカし半径のガウスフィルタ」を用いてボカし，これを被写界深度効果フレームとする。この被写界深度効果フレームとシーンのレンダリング結果とを，解像度を揃えて合成するときに，前述のフォーカス情報を見て，ピンボケのところは被写界深度効果フレームの割合を多く，ピントが合っているところは割合を少なくして合成する。

　こうすることで，ピンぼけのところボケが出る一方，ピントが合っているところはクリアに見えるようになるのだ。



 



●モーションブラー（Motion Blur）



image

ホバークラフトのウイングや，奥の岩肌がブレて見えているのは，モーションブラーによるもの



　3Dグラフィックスのフレームは，喩えるなら「シャッター速度が無限大分の1仕様となっているカメラで撮影した結果」なのでブレることはない。しかし実際のカメラでは，映像を写し取るのに，シャッタースピードに応じた時間が必要なので，その間に被写体が動くとブレて映ってしまう。そこで，この「動きによって生じるブレ」を表現するものとして用意された効果が，モーションブラーである。

　3Dゲームグラフィックスでは，モーションブラーをあえて付加することによって，これまた写実的な映像を目指そうとする動きが強いのだ。余談だが，このモーションブラー効果は，「相手を狙いにくくするノイズでしかない」と，ハードコアなFPSゲーマーからは不人気なのだとか。



　さて，モーションブラーには視点の移動によってシーン全体がブレて見える「カメラ・モーションブラー」（Camera Motion Blur，以下CMB）と，シーン内の3Dキャラクターが動いてそれがブレて見える「オブジェクト・モーションブラー」（Object Motion Blur，以下OMB）の2タイプあるが，3DMark VantageではOMBに対応している。その技法は「Crysis」や「ロスト プラネット エクストリーム コンディション」で採用されたものとよく似たタイプだ。

　OMB生成には画面上の全ピクセル単位の速度分布を記録したテクスチャ「ベロシティマップ」（Velocity Map）が必要になる。これは，各3Dキャラクターについて，前フレームにおける各頂点の位置と現在フレームでの各頂点の位置の差分から求めた各頂点単位の速度情報を基に，視点から見たピクセル単位の速度情報を弾き出して，各αRGB16bit整数のバッファ（int16-64bit）に出力していくことで生成する。



 



image

移動方向にぶれているのが分かる



　あとは，このベロシティマップから取り出した速度情報をベースに，シーンのレンダリング結果をブレさせる加工を施せば出来上がりだ。先の2タイトルではベロシティマップを強調するプロセスを挟み込むことで，よりダイナミックなOMBを実現していたが，3DMark Vantageではそこまではやっていないようである。



 



●深度フォグ（Depth Fog）



image

基地内の奥（※画面では右側）が白っぽく見えるのが深度フォグの効果。かなり淡目にかかっている



　フォグ，つまり霧は，遠くのほうが霞んで見える，お手軽な空気遠近法の実現手段だ。

　3DMark Vantageでは，この空気遠近の効果を，「シーンのレンダリングを終えたあとのZバッファの内容（＝深度値）を見つつ，各ピクセルについて，その深度値（＝奥行き）に応じてフォグ色を強くしていくような加工処理を施す」ことで表現している。このような，深度値を見ながらのフォグ処理なので「深度フォグ」というわけだ。

　ちなみに，地表などの基準高からの一定の高さまでについてフォグ処理を行う，「高さフォグ」（Height Fog）というものもある。これは，3DMark06において，水深方向の霞み表現に使われていた。



 



●ボリュームフォグ（Volumetric Fog）



image

ボリュームテクスチャとは“フォグの断面図”的なもので，フォグの密度や色が記録されている。レンダリング時には，各ピクセル位置から伸ばした視線と，そのフォグとが衝突したところ（図中左のX）から一定距離間隔ごとに突き進ませてボリュームテクスチャをサンプルし，その値でライティング。障害物があればそこでライティングを打ち切ることにしつつ，フォグ領域を突き出るまで繰り返すのだ。フォグ領域を突き出た場合は，当然のことながら不透明度が増す



　雲のような，ある程度の形状を持ったフォグをボリュームフォグ（Volumetric Fog）という。奥行き方向の全体的なフォグしか表現できないのが深度フォグなので，対応するようにあえて和訳するならば“立体的なフォグ”といったところか。

　ボリュームフォグの表現には，フォグの密度と色を記録した，フォグの「ボリュームテクスチャ」（Volumetric Texture）を用意する。ボリュームテクスチャというのは，「表現対象の断面図」だと思えばいい。CTスキャンみたいなイメージだ。表現したい霧の形状をボリュームテクスチャとして用意しておくわけである。



　あるピクセルをレンダリングするときは，まさにCTスキャンで輪切りにしたイメージになるボリュームテクスチャからフォグの濃度と色を取り出し，当該ピクセルの透明度を算出（＝ライティング計算を実行）する。断面図から実態を再構成する，いわゆるボリュームレンダリングを行うわけだ。



 



image

MicrosoftのDirectX 10デモに含まれる「VolumeSoft」より。同デモにおけるボリュームフォグの実装は，3DMark Vantageのそれとよく似ている



　3DMark Vantageオリジナルの工夫としては，ボリュームテクスチャを適当なリズムで拡大縮小してからサンプル（してボリュームレンダリング）するというものが挙げられよう。これにより，生成されたボリュームフォグが微妙に動いて，対流しているかのようなアニメーション効果が出せたとのことだ。

　凝っているのは，ボリュームレンダリング時にちゃんとシーンのシャドウマップも吟味しているという点。この配慮により，他者の影がちゃんとこのボリュームフォグ上にも投射される。



 



image

隕石の間にうっすらと複数の土埃の固まりみたいなのが見えるが，これがボリュームフォグ



　ボリュームレンダリングは，いわばレイトレーシングみたいなものなので，処理にかかる負荷が高い。そこで3DMark Vantageではこのボリュームフォグのレンダリングに関しては，ターゲット解像度の縦横4分の1，面積比16分の1となる低解像度でレンダリングしたものを拡大して合成している。また，上の図で示した「フォグ領域」は，円柱形状で管理される簡易的なものになっているという。



 



●トーンマッピング（Tone Mapping）



　3Dグラフィックスはこれまで，RGB各8bit（＝24bitカラー）というダイナミックレンジに縛られてレンダリングしなければならなかった。

　しかし，当たり前だが，現実世界の視界にそういった制約はなく，幅広いダイナミックレンジの光（※輝度や色）に満ちあふれている。人間なら瞳，あるいはカメラならレンズの露出やシャッター速度をそれぞれ調整することで，それぞれにとって適切な輝度の範囲にまとめ，見やすくしているのだ。



 



imageimage

連続したカメラシーケンスより。基地内の暗いシーンを捉えていた直後に，日の差し込む情景にカメラを向けたことで，日の当たっている高輝度な岩肌の陰影が飛んでいる。こうしたHDR表現が動的なトーンマッピングの効果だ



 



　さて，RGB各8bitを超えるHDR（High Dynamic Range）レンダリングについては，連載バックナンバー「『Half-Life 2: Lost Coast』でHDRレンダリングの実体をチェックする」をぜひチェックしてほしいと思うが，HDRレンダリングされたフレームというのは，そのままだと普通のディスプレイには表示できない。3DMark Vantageの場合，FP16-64bitの浮動小数点バッファでレンダリングされているため，一般的な整数8bit RGB駆動のディスプレイ装置で表示できるわけがないのだ。

　そこで，「人間の瞳やカメラのレンズによる露出補正」に相当する処理を行ったうえで，適切な輝度，すなわち普通のディスプレイに表示可能な映像フレームへ変換してやる必要が出てくる。そして，これを行うのが「トーンマッピング」と呼ばれる処理系になる。



　役割はシンプルでありながら，奥行きが深いテーマであるトーンマッピング。それだけに，どのような実装になっているのか非常に気になるのだが，残念ながらFuturemarkは「露出変調とガンマ補正付きの，シンプルなトーンマッピング処理を行っている」という説明しかしていない。



 



 



まずまず現実的なDirectX X10/SM4.0対応

 



　第1回の冒頭で述べたとおり，ここまではとくに，3DMark Vantageのグラフィックスエンジンについて詳解してみた。



 



image

VSM技法を採用したゲームエンジンの代表格といえるのがEpic GamesのUnreal Engine 3.0だ。画面は同エンジンベースのタイトル「Gears of War」より

（C）2008 Microsoft Corporation. All Rights Reserved



　通して見てきた感じでは，3DMark06のグラフィックスエンジンと比較して，基本アーキテクチャ面に大きな進化はないものの，現行世代で使われている，あるいはやや先の3Dゲームで使われるであろうテクノロジーが，けっこう貪欲に取り入れられているという手応えはある。

　例えばバリアンス・シャドウマップ（VSM）の影生成技法は本当に採用例が多くなっているし，数々のポストプロセスについては，3DMark Vantageに近い形の実装を現実に行っているエンジンもある。GPUに現実的な負荷をかける目的の3Dグラフィックスベンチマークアプリケーションとしては，面目躍如といったところだろうか。



　そのなかでも，とくにいい未来予測といえるのが，グラフィックス素材となる要素をCPUでなくGPUでシミュレーションして生成しているという部分。具体的には水面の波動シミュレーションや布の物理シミュレーションのことだ。AGEIA Technologiesを買収したNVIDIAが，GeForceでPhysX物理シミュレーションをアクセラレートするのは既定路線だし，ゲームデベロッパの間でも，今後，GPUでできる物理シミュレーションはどんどんやっていこうという流れが生まれつつあるので，このGPGPU的要素をテストに組み込んだ意義は高いと思う。

　欲をいえば，ゲーム開発者会議であるGame Developers Conference 2008（GDC2008）でも関連セッションが相当な数に上った「プロシージャル・アプローチのシェーダ技術」の要素も，何かしらエンジンに組み込んでほしかったが。



 



image

NVIDIAのGeForce 8000シリーズ用デモ「Cascades」



　なお，プロシージャル（Procedural）とは，日本語だと「手続き」の意だが，3Dグラフィックスの世界では，GPUに適当な“種（タネ）”とAI的な適応型のアルゴリズムを与えて，何かを生成させるような処理系を指す。

　最近の実例でいうと，GPUが地形と水，昆虫を自動生成して動かすNVIDIAのデモ「Cascades」や，Crytekが「Crysis」に組み込んだ，夏場のアートセット上に凍結シーンをプロシージャル生成する凍結シェーダのような技術がこれに相当する。



 



imageimage

「Crysis」におけるプロシージャル凍結シェーダ

（C）2007 Crytek. All Rights Reserved. Crytek, Crysis and CryENGINE are trademarks or registered trademarks of Crytek. EA and the EA logo are trademarks or registered trademarks of Electronic Arts Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.



 



　このほかにも，Ubisoft Entertainmentが開発中の「Far Cry 2」も，植物の生成と成長，天候の制御などをプロシージャル技術で実現しており，プロシージャル技術はGPGPUと並んで次世代の技術トレンドになる可能性がある。次期3DMarkにはぜひ取り入れてほしい要素だ。



　最後に，気になる「3DMark VantageのDirectX 10対応度」についても簡単に言及しておこう。

　DirectX 10の目玉要素であるジオメトリシェーダは，パーティクルシステムに活用されている。煙や火花，水しぶきなどのパーティクルは，管理情報としては一頂点だが，ジオメトリシェーダで頂点を増殖させてポリゴン化し，スプライトに変換しているのだ。やや“甘口”な使い方だが，DirectX 10時代の序幕といえる今日（こんにち）的には，まあ現実的な使い方ともいえる。



　DirectX 10パイプラインの新要素となるストリームアウトの機能は，第1回で説明したとおり，GPUで行った布の物理シミュレーション結果を頂点シェーダに戻してグラフィックス処理させるための，再帰的処理系の実現に使われている。

　そのほか，テキスト断片で管理されているシェーダプログラムを合成し，1本のロングシェーダにまとめ上げて活用するという仕組みは，DirectX 10/SM4.0におけるシェーダプログラム長制限の（事実上の）撤廃や，シェーダリソース群の増強がなければ実現しなかっただろう。

　積極活用とはいえず，全体的に地味な印象には留まるものの，3DMark Vantageのエンジンは，確かにDirectX 10/SM4.0の恩恵を受けているのだ。



　一方，賛否両論あるDirectX 10.1のプログラマブルシェーダ4.1仕様は，現行の3DMark Vantageでサポートされていない。痒いところに手が届く機能も多く，レンダリング結果の品質を厳密に管理できるプログラマブルアンチエイリアシング系の機能はベンチマークソフト向きともいえるのだが，対応予定について今のところ特別なアナウンスはなく，ホワイトペーパーにも言及はなかった。



 
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2020, All Tool Manual.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>